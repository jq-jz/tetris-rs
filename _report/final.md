# 基于 Rust 的俄罗斯方块游戏开发项目报告

## 一、实验目的

-   **设计目标与待解决问题**
    本项目的主要目标是使用 Rust 编程语言及其生态流行的 Bevy 框架，从零开始完整实现一个功能齐全的经典俄罗斯方块游戏。要解决的核心问题包括：
    1.  学习并实践 Rust 语言的特性。
    2.  掌握 Bevy 框架的核心设计范式，实体组件系统（Entity-Component-System, ECS）。
    3.  实现俄罗斯方块的核心游戏逻辑，包括方块的生成、移动、旋转、下落、锁定、消行计分以及游戏结束判断。
    4.  构建一个完整的游戏循环，处理玩家输入、更新游戏状态并实时渲染游戏画面。

-   **用户体验与性能评估**
    项目旨在提供流畅、直观、无延迟的游戏体验。通过 Bevy 框架的数据驱动架构，确保了高效的渲染和逻辑处理，即使用“每帧重绘”的简单渲染策略，也能在目标硬件上实现高帧率运行，保证玩家操作的即时响应。

## 二、实验环境

-   **开发工具**：
    -   代码编辑器：Visual Studio Code / Zed
    -   构建工具与包管理器：Cargo 1.90.0
    -   编译器：rustc 1.90.0

-   **操作系统**：Windows 11 / macOS Tahoe 26.0.1

-   **设备与运行环境**：
    -   项目编译为本地可执行文件，直接运行。

-   **依赖与 SDK**：
    -   游戏框架：`bevy = "0.17.2"`
    -   随机数生成库：`rand = "0.9"`

## 三、实验原理

-   **核心概念与技术路线**
    本项目采用 Bevy 框架提供的 **实体组件系统 (ECS)** 作为核心架构。该架构将传统面向对象中的“对象”拆分为三个独立部分：
    1.  **实体 (Entity)**：一个唯一的ID，代表游戏中的一个“事物”，如一个方块格、一段UI文字。
    2.  **组件 (Component)**：附加在实体上的纯数据，用于描述其属性。例如 `Transform` (位置)、`Sprite` (外观)、`Block` (自定义标签)。
    3.  **系统 (System)**：处理带有特定组件集的实体的逻辑（函数）。例如，`rendering` 系统负责绘制所有带 `Sprite` 和 `Transform` 的实体。

    此外，项目还使用了 Bevy 的 **资源 (Resource)** 概念来管理全局唯一的游戏状态，如 `GameState` (游戏进程、分数) 和 `GameBoard` (棋盘数据)，实现了数据与逻辑的彻底分离。

-   **关键机制与实现思路**
    游戏的核心是**游戏循环 (Game Loop)**，由 Bevy 框架驱动。
    在 `main.rs` 中，我们定义了循环中各系统的执行顺序。系统采用并行执行策略，虽然不保证严格的执行顺序，但 Bevy 的资源访问控制会自动同步，确保数据安全。这种设计创造了一个微妙的时间窗口，允许玩家在方块即将锁定时仍能调整位置，类似现代俄罗斯方块的"Lock Delay"机制，提供了更好的游戏体验。

    **游戏主循环流程图:**

    ```mermaid
    graph TD
        A[开始] --> B{处理玩家输入};
        B --> C{更新游戏逻辑};
        C --> D[处理方块下落];
        D --> E[处理方块锁定];
        E --> F[处理消行与计分];
        F --> G[生成新方块];
        G --> H{渲染游戏画面};
        H --> I[绘制棋盘与已锁定方块];
        I --> J[绘制当前活动方块];
        J --> K[绘制UI文本];
        K --> B;
    ```
    此流程在每一帧重复执行，构成了游戏的实时交互体验。

## 四、实验步骤

### （一）需求分析与设计规划

-   **用户画像与场景**：面向所有年龄段的休闲游戏玩家。

-   **功能需求列表**：
    -   **P0 (必须)**：方块可左右移动、旋转、加速下落（软降）、瞬间下落（硬降）。
    -   **P0 (必须)**：方块在触底或接触其他方块后自动锁定。
    -   **P0 (必须)**：填满一行或多行后，行被消除并计分。
    -   **P0 (必须)**：游戏区域堆满后，游戏结束。
    -   **P1 (重要)**：显示当前分数、下一个方块预览。
    -   **P1 (重要)**：支持游戏暂停/继续、重新开始。
-   **交互与信息架构**：
    游戏主要在一个单页面内完成所有交互。信息结构简单，主要包括游戏主区域、分数显示区和下一个方块预览区。

-   **原型与线框**：
    设计基于经典的俄罗斯方块布局。游戏区为 10x20 网格，位于屏幕中央；分数在左上角；下一个方块预览在右上角；暂停/游戏结束提示居中显示。

### （二）项目创建与环境配置

-   **项目创建**：使用 Cargo 命令 `cargo new tetris-rs --bin` 创建一个新的二进制 Rust 项目。
-   **依赖配置**：在项目根目录的 `Cargo.toml` 文件中，添加 `[dependencies]` 部分，引入 `bevy` 和 `rand` 库。
    ```toml
    [dependencies]
    bevy = "0.13"
    rand = "0.8.5"
    ```
    执行 `cargo build` 即可自动下载并编译所有依赖。

### （三）界面布局设计

-   **整体布局思路**：
    采用 Bevy 的 2D 正交摄像头 `Camera2d`。
    游戏世界的布局基于世界坐标系（原点在屏幕中心）。
    我们通过自定义的 `grid_to_world` 函数，将逻辑层面的网格坐标 (如 `x:0, y:0`) 精确转换为渲染层面的世界坐标。

-   **核心布局实现 (`constants.rs`)**：
    `grid_to_world(x, y)` 函数是布局的核心。
    它首先计算出整个 10x20 游戏网格在世界坐标中的左上角基准点，然后根据传入的网格坐标 `(x, y)` 和常量 `CELL_SIZE` 计算出对应方块格的中心点世界坐标。

-   **组件摆放与层级 (`rendering.rs`)**：
    -   **游戏区**：通过两层循环遍历 `GameBoard` 资源，为每个网格单元格生成一个背景 `Sprite` 实体，如果该单元格有锁定的方块，则再其上层（通过更高的 Z 坐标）生成一个带颜色的 `Sprite` 实体。
    -   **UI 文本**：通过 Bevy UI 系统创建 `Node` 实体，并使用 `PositionType::Absolute` 结合 `top`, `left` 属性实现精确定位（如分数置于左上角）。

### （四）界面样式设计

-   **样式与资源**：
    -   **颜色**：方块的颜色与 `TetrominoType` 枚举绑定。在 `tetromino.rs` 的 `color()` 方法中，为七种方块各指定了一个明确的 `Color::srgb(...)` 值。
    -   **大小**：所有游戏方块的大小由常量 `CELL_SIZE` 统一控制。
    -   **字体**：UI 文本的字体大小和颜色在 `setup_game` 函数中创建实体时直接指定。

-   **主题设置**：
    本项目未实现复杂的主题切换功能。游戏背景色和方块颜色是硬编码的，以还原经典游戏的视觉风格。

### （五）交互设计实现

-   **事件绑定 (`player_input.rs`)**：
    在 `handle_player_input` 系统中，通过查询 Bevy 的 `Res<ButtonInput<KeyCode>>` 资源来获取键盘输入。使用 `keyboard.just_pressed(...)` 方法检测特定按键（如 `KeyCode::ArrowLeft`, `KeyCode::Space`）的单次按下事件，并据此修改 `GameState` 资源中当前活动方块的位置或旋转状态。

-   **页面导航（游戏状态转换）**：
    游戏没有多页面导航，而是通过改变 `GameState` 资源中的布尔标志 `paused` 和 `game_over` 来实现状态转换。
    -   按下 `ESC` 键会切换 `paused` 的值。
    -   当方块堆叠至顶部时，`game_over` 被设为 `true`。
    `update_ui` 和 `update_game_logic` 等系统会根据这些标志决定自身的行为（如暂停时逻辑停止，游戏结束时显示提示信息）。

-   **状态管理**：
    如前所述，`GameState` 和 `GameBoard` 这两个全局资源是唯一的数据源 (Single Source of Truth)。所有系统都通过只读 (`Res<T>`) 或可写 (`ResMut<T>`) 的方式访问这些资源，以读取状态或执行更新，保证了数据流的一致性和可预测性。

### （六）测试与调试

-   **功能测试**：通过手动操作进行测试，确保所有功能符合预期。
    | 测试用例 | 操作步骤 | 预期结果 |
    | :--- | :--- | :--- |
    | 方块移动 | 按下左右方向键 | 方块在边界内正常左右移动一格 |
    | 方块旋转 | 按下上方向键 | 方块顺时针旋转90度，且不会穿墙 |
    | 硬降 | 按下空格键 | 方块立即下落并锁定在最底部 |
    | 消行与计分 | 填满一行 | 该行被消除，上方方块下落，分数增加100分 |
    | 游戏结束 | 方块堆叠到顶部 | 屏幕显示 "GAME OVER"，游戏逻辑停止 |
    | 暂停/继续 | 按下ESC键 | 游戏画面静止，显示暂停菜单/恢复游戏 |

## 五、实验结果

-   **目标对照**：
    项目成功完成了预设的全部 P0 和 P1 级功能需求。实现了完整的俄罗斯方块游戏体验，达到了学习 Rust 和 Bevy 框架的实验目的。

-   **界面与功能展示**：
    *   **游戏进行中截图**：可展示一个典型的游戏画面，包括各种颜色的方块、当前下落的方块、右侧的下一个方块预览和左上角的分数。
    *   **暂停界面截图**：可展示按下 `ESC` 后的画面，游戏静止，屏幕中央显示 "PAUSED" 提示。
    *   **游戏结束截图**：可展示方块堆满后，屏幕中央显示 "GAME OVER" 的最终画面。

## 六、问题与反思

-   **主要问题与成因分析**：
    1.  **渲染效率**：`render_game` 系统采用“每帧销毁全部方块再全部重绘”的策略。虽然对于此项目规模性能足够，但对于实体数量庞大的游戏，这将是严重的性能瓶颈。
    2.  **旋转系统过于简单**：`rotate_point` 函数只实现了简单的数学旋转，未实现官方俄罗斯方块规则中的“墙踢 (Wall Kick)”机制，导致方块在贴近墙壁或其它方块时旋转体验不佳。

-   **解决方案与权衡**：
    1.  **渲染优化**：更优的方案是在游戏启动时创建所有需要的实体，渲染系统每帧只更新它们的 `Transform` (位置) 和 `Sprite` (颜色/可见性) 组件，而非销毁和重建。本项目为简化逻辑，选择了实现更简单的重绘方案。
    2.  **高级旋转**：实现"墙踢"需要引入一套复杂的偏移检测规则（如 SRS 旋转系统），在旋转发生碰撞时，按预定规则尝试几个偏移位置。考虑到项目复杂度，本次实现中省略了该高级功能。
    3.  **系统执行策略**：项目选择了并行系统执行而非链式执行（`.chain()`）。虽然链式执行能保证严格的执行顺序，但会导致方块触底后立即锁定，玩家无法在最后时刻调整位置。并行执行虽然执行顺序不确定，但在 Bevy 的资源访问控制下仍能保证数据安全，且意外地实现了类似"Lock Delay"的效果，允许玩家在方块即将锁定时进行微调，这符合现代俄罗斯方块的游戏设计理念，提供了更好的游戏体验和容错空间。

-   **待优化项与后续计划**：
    -   增加音效和背景音乐。
    -   引入关卡系统，随分数增加，方块下落速度加快。
    -   实现一个更完善的主菜单和设置界面。

## 七、总结与展望

-   **收获与经验**：
    通过本项目，我们深刻理解了 ECS 架构的优势，它将数据和逻辑解耦，使代码结构非常清晰、模块化。同时，也熟练掌握了 Rust 的核心特性，特别是在 Bevy 的系统中，其所有权和借用检查机制（如 `Res` 和 `ResMut`）从根本上杜绝了数据竞争问题，提升了代码的健壮性。

-   **可扩展方向**：
    当前架构具有良好的可扩展性。可以方便地添加新的组件和系统来实现新功能，例如，可以添加一个 `Level` 资源和一个 `update_speed` 系统来轻松实现关卡难度递增功能。代码逻辑清晰，也为后续重构和性能优化打下了良好基础。

## 八、参考文献

-   [1] The Bevy Book. https://bevy.org/learn/quick-start/introduction/
-   [2] The Rust Programming Language. https://doc.rust-lang.org/book/

## 九、附录

-   **源码仓库**：`https://github.com/jq-jz/tetris-rs`
-   **运行步骤**：
    1.  安装 Rust 工具链。
    2.  克隆源码仓库。
    3.  在项目根目录下运行 `cargo run` 命令即可编译并启动游戏。
